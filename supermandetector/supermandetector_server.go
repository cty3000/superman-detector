//
// Code generated by rdl 1.5.2 DO NOT EDIT.
//

package supermandetector

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strings"

	rdl "github.com/ardielle/ardielle-go/rdl"
	"github.com/dimfeld/httptreemux"
)

var _ = json.Marshal
var _ = ioutil.Discard

//
// Init initializes the SupermanDetector server with a service identity and an
// implementation (SupermanDetectorHandler), and returns an http.Handler to serve it.
//
func Init(impl SupermanDetectorHandler, baseURL string, authz rdl.Authorizer, authns ...rdl.Authenticator) http.Handler {
	u, err := url.Parse(strings.TrimSuffix(baseURL, "/"))
	if err != nil {
		log.Fatal(err)
	}
	b := u.Path
	router := httptreemux.New()
	adaptor := SupermanDetectorAdaptor{impl, authz, authns, b}

	router.POST(b+"/", func(w http.ResponseWriter, r *http.Request, ps map[string]string) {
		adaptor.postIpAccessRequestHandler(w, r, ps)
	})
	router.NotFoundHandler = func(w http.ResponseWriter, r *http.Request) {
		rdl.JSONResponse(w, 404, rdl.ResourceError{Code: http.StatusNotFound, Message: "Not Found"})
	}
	log.Printf("Initialized SupermanDetector service at '%s'\n", baseURL)
	return router
}

//
// SupermanDetectorHandler is the interface that the service implementation must conform to
//
type SupermanDetectorHandler interface {
	PostIpAccessRequest(context *rdl.ResourceContext, request *IpAccessRequest) (*IpAccessResponse, error)
	Authenticate(context *rdl.ResourceContext) bool
}

//
// SupermanDetectorAdaptor - this adapts the http-oriented router calls to the non-http service handler.
//
type SupermanDetectorAdaptor struct {
	impl           SupermanDetectorHandler
	authorizer     rdl.Authorizer
	authenticators []rdl.Authenticator
	endpoint       string
}

func (adaptor SupermanDetectorAdaptor) authenticate(context *rdl.ResourceContext) bool {
	if adaptor.authenticators != nil {
		for _, authn := range adaptor.authenticators {
			var creds []string
			var ok bool
			header := authn.HTTPHeader()
			if strings.HasPrefix(header, "Cookie.") {
				if cookies, ok2 := context.Request.Header["Cookie"]; ok2 {
					prefix := header[7:] + "="
					for _, c := range cookies {
						if strings.HasPrefix(c, prefix) {
							creds = append(creds, c[len(prefix):])
							ok = true
							break
						}
					}
				}
			} else {
				creds, ok = context.Request.Header[header]
			}
			if ok && len(creds) > 0 {
				principal := authn.Authenticate(creds[0])
				if principal != nil {
					context.Principal = principal
					return true
				}
			}
		}
	}
	if adaptor.impl.Authenticate(context) {
		return true
	}
	log.Println("*** Authentication failed against all authenticator(s)")
	return false
}

func (adaptor SupermanDetectorAdaptor) authorize(context *rdl.ResourceContext, action string, resource string) bool {
	if adaptor.authorizer == nil {
		return true
	}
	if !adaptor.authenticate(context) {
		return false
	}
	ok, err := adaptor.authorizer.Authorize(action, resource, context.Principal)
	if err == nil {
		return ok
	}
	log.Println("*** Error when trying to authorize:", err)
	return false
}

func intFromString(s string) int64 {
	var n int64 = 0
	_, _ = fmt.Sscanf(s, "%d", &n)
	return n
}

func floatFromString(s string) float64 {
	var n float64 = 0
	_, _ = fmt.Sscanf(s, "%g", &n)
	return n
}

func (adaptor SupermanDetectorAdaptor) postIpAccessRequestHandler(writer http.ResponseWriter, request *http.Request, params map[string]string) {
	context := &rdl.ResourceContext{Writer: writer, Request: request, Params: params, Principal: nil}
	var argRequest *IpAccessRequest
	oserr := json.NewDecoder(request.Body).Decode(&argRequest)
	if oserr != nil {
		rdl.JSONResponse(writer, http.StatusBadRequest, rdl.ResourceError{Code: http.StatusBadRequest, Message: "Bad request: " + oserr.Error()})
		return
	}
	data, err := adaptor.impl.PostIpAccessRequest(context, argRequest)
	if err != nil {
		switch e := err.(type) {
		case *rdl.ResourceError:
			rdl.JSONResponse(writer, e.Code, err)
		default:
			rdl.JSONResponse(writer, 500, &rdl.ResourceError{Code: 500, Message: e.Error()})
		}
	} else {
		rdl.JSONResponse(writer, 200, data)
	}

}
