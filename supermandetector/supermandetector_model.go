//
// Code generated by rdl 1.5.2 DO NOT EDIT.
//

package supermandetector

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// Octet -
//
type Octet string

//
// IPAddress -
//
type IPAddress string

//
// UnixTimestamp -
//
type UnixTimestamp int32

//
// Lat -
//
type Lat float64

//
// Lon -
//
type Lon float64

//
// Radius -
//
type Radius int32

//
// Speed -
//
type Speed int32

//
// IpAccessRequest -
//
type IpAccessRequest struct {
	Username       string    `json:"username"`
	Unix_timestamp int32     `json:"unix_timestamp"`
	Event_uuid     string    `json:"event_uuid"`
	Ip_address     IPAddress `json:"ip_address"`
}

//
// NewIpAccessRequest - creates an initialized IpAccessRequest instance, returns a pointer to it
//
func NewIpAccessRequest(init ...*IpAccessRequest) *IpAccessRequest {
	var o *IpAccessRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IpAccessRequest)
	}
	return o
}

type rawIpAccessRequest IpAccessRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a IpAccessRequest
//
func (self *IpAccessRequest) UnmarshalJSON(b []byte) error {
	var m rawIpAccessRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IpAccessRequest(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *IpAccessRequest) Validate() error {
	if self.Username == "" {
		return fmt.Errorf("IpAccessRequest.username is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "String", self.Username)
		if !val.Valid {
			return fmt.Errorf("IpAccessRequest.username does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Event_uuid == "" {
		return fmt.Errorf("IpAccessRequest.event_uuid is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "String", self.Event_uuid)
		if !val.Valid {
			return fmt.Errorf("IpAccessRequest.event_uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Ip_address == "" {
		return fmt.Errorf("IpAccessRequest.ip_address is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "IPAddress", self.Ip_address)
		if !val.Valid {
			return fmt.Errorf("IpAccessRequest.ip_address does not contain a valid IPAddress (%v)", val.Error)
		}
	}
	return nil
}

//
// CurrentGeo -
//
type CurrentGeo struct {
	Lat    float64 `json:"lat"`
	Lon    float64 `json:"lon"`
	Radius int32   `json:"radius"`
}

//
// NewCurrentGeo - creates an initialized CurrentGeo instance, returns a pointer to it
//
func NewCurrentGeo(init ...*CurrentGeo) *CurrentGeo {
	var o *CurrentGeo
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(CurrentGeo)
	}
	return o
}

type rawCurrentGeo CurrentGeo

//
// UnmarshalJSON is defined for proper JSON decoding of a CurrentGeo
//
func (self *CurrentGeo) UnmarshalJSON(b []byte) error {
	var m rawCurrentGeo
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := CurrentGeo(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *CurrentGeo) Validate() error {
	return nil
}

//
// IpAccess -
//
type IpAccess struct {
	Ip        IPAddress `json:"ip"`
	Speed     int32     `json:"speed"`
	Lat       float64   `json:"lat"`
	Lon       float64   `json:"lon"`
	Radius    int32     `json:"radius"`
	Timestamp int32     `json:"timestamp"`
}

//
// NewIpAccess - creates an initialized IpAccess instance, returns a pointer to it
//
func NewIpAccess(init ...*IpAccess) *IpAccess {
	var o *IpAccess
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IpAccess)
	}
	return o
}

type rawIpAccess IpAccess

//
// UnmarshalJSON is defined for proper JSON decoding of a IpAccess
//
func (self *IpAccess) UnmarshalJSON(b []byte) error {
	var m rawIpAccess
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IpAccess(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *IpAccess) Validate() error {
	if self.Ip == "" {
		return fmt.Errorf("IpAccess.ip is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "IPAddress", self.Ip)
		if !val.Valid {
			return fmt.Errorf("IpAccess.ip does not contain a valid IPAddress (%v)", val.Error)
		}
	}
	return nil
}

//
// IpAccessResponse -
//
type IpAccessResponse struct {
	CurrentGeo                     *CurrentGeo `json:"currentGeo"`
	TravelToCurrentGeoSuspicious   *bool       `json:"travelToCurrentGeoSuspicious,omitempty" rdl:"optional"`
	TravelFromCurrentGeoSuspicious *bool       `json:"travelFromCurrentGeoSuspicious,omitempty" rdl:"optional"`
	PrecedingIpAccess              *IpAccess   `json:"precedingIpAccess,omitempty" rdl:"optional"`
	SubsequentIpAccess             *IpAccess   `json:"subsequentIpAccess,omitempty" rdl:"optional"`
}

//
// NewIpAccessResponse - creates an initialized IpAccessResponse instance, returns a pointer to it
//
func NewIpAccessResponse(init ...*IpAccessResponse) *IpAccessResponse {
	var o *IpAccessResponse
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IpAccessResponse)
	}
	return o.Init()
}

//
// Init - sets up the instance according to its default field values, if any
//
func (self *IpAccessResponse) Init() *IpAccessResponse {
	if self.CurrentGeo == nil {
		self.CurrentGeo = NewCurrentGeo()
	}
	return self
}

type rawIpAccessResponse IpAccessResponse

//
// UnmarshalJSON is defined for proper JSON decoding of a IpAccessResponse
//
func (self *IpAccessResponse) UnmarshalJSON(b []byte) error {
	var m rawIpAccessResponse
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IpAccessResponse(m)
		*self = *((&o).Init())
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *IpAccessResponse) Validate() error {
	if self.CurrentGeo == nil {
		return fmt.Errorf("IpAccessResponse: Missing required field: currentGeo")
	}
	return nil
}

//
// IpAccessRecord -
//
type IpAccessRecord struct {
	Username       string    `json:"username"`
	Unix_timestamp int32     `json:"unix_timestamp"`
	Event_uuid     string    `json:"event_uuid"`
	Ip_address     IPAddress `json:"ip_address"`
	Lat            float64   `json:"lat"`
	Lon            float64   `json:"lon"`
	Radius         int32     `json:"radius"`
}

//
// NewIpAccessRecord - creates an initialized IpAccessRecord instance, returns a pointer to it
//
func NewIpAccessRecord(init ...*IpAccessRecord) *IpAccessRecord {
	var o *IpAccessRecord
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(IpAccessRecord)
	}
	return o
}

type rawIpAccessRecord IpAccessRecord

//
// UnmarshalJSON is defined for proper JSON decoding of a IpAccessRecord
//
func (self *IpAccessRecord) UnmarshalJSON(b []byte) error {
	var m rawIpAccessRecord
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := IpAccessRecord(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *IpAccessRecord) Validate() error {
	if self.Username == "" {
		return fmt.Errorf("IpAccessRecord.username is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "String", self.Username)
		if !val.Valid {
			return fmt.Errorf("IpAccessRecord.username does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Event_uuid == "" {
		return fmt.Errorf("IpAccessRecord.event_uuid is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "String", self.Event_uuid)
		if !val.Valid {
			return fmt.Errorf("IpAccessRecord.event_uuid does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Ip_address == "" {
		return fmt.Errorf("IpAccessRecord.ip_address is missing but is a required field")
	} else {
		val := rdl.Validate(SupermanDetectorSchema(), "IPAddress", self.Ip_address)
		if !val.Valid {
			return fmt.Errorf("IpAccessRecord.ip_address does not contain a valid IPAddress (%v)", val.Error)
		}
	}
	return nil
}
